<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Bootstrapper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Restheart</a> &gt; <a href="index.source.html" class="el_package">org.restheart</a> &gt; <span class="el_source">Bootstrapper.java</span></div><h1>Bootstrapper.java</h1><pre class="source lang-java linenums">/*
 * RESTHeart - the data REST API server
 * Copyright (C) 2014 - 2015 SoftInstigate Srl
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.restheart;

import com.mongodb.MongoClient;
import static org.restheart.Configuration.RESTHEART_VERSION;
import org.restheart.db.MongoDBClientSingleton;
import org.restheart.handlers.ErrorHandler;
import org.restheart.handlers.GzipEncodingHandler;
import org.restheart.handlers.PipedHttpHandler;
import org.restheart.handlers.RequestDispacherHandler;
import org.restheart.handlers.injectors.RequestContextInjectorHandler;
import org.restheart.handlers.injectors.CollectionPropsInjectorHandler;
import org.restheart.handlers.injectors.DbPropsInjectorHandler;
import org.restheart.handlers.injectors.LocalCachesSingleton;
import org.restheart.security.AccessManager;
import org.restheart.utils.ResourcesExtractor;
import org.restheart.utils.LoggingInitializer;
import org.restheart.handlers.RequestContext;
import org.restheart.handlers.applicationlogic.ApplicationLogicHandler;
import org.restheart.handlers.OptionsHandler;
import org.restheart.handlers.PipedWrappingHandler;
import org.restheart.handlers.injectors.BodyInjectorHandler;
import org.restheart.security.handlers.SecurityHandlerDispacher;
import org.restheart.security.handlers.CORSHandler;
import org.restheart.utils.FileUtils;
import org.restheart.utils.OSChecker;
import com.sun.akuma.Daemon;
import static io.undertow.Handlers.path;
import io.undertow.Undertow;
import io.undertow.security.idm.IdentityManager;
import io.undertow.server.handlers.HttpContinueAcceptingHandler;
import io.undertow.server.handlers.resource.FileResourceManager;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;

import static io.undertow.Handlers.resource;
import io.undertow.Undertow.Builder;
import io.undertow.server.handlers.AllowedMethodsHandler;
import io.undertow.server.handlers.BlockingHandler;
import io.undertow.server.handlers.GracefulShutdownHandler;
import io.undertow.server.handlers.PathHandler;
import io.undertow.server.handlers.RequestLimit;
import io.undertow.server.handlers.RequestLimitingHandler;
import io.undertow.server.handlers.resource.ResourceHandler;
import io.undertow.util.HttpString;
import java.lang.reflect.InvocationTargetException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import org.restheart.security.FullAccessManager;
import org.restheart.security.handlers.AuthTokenHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author Andrea Di Cesare &lt;andrea@softinstigate.com&gt;
 */
<span class="nc" id="L89">public final class Bootstrapper {</span>

<span class="nc" id="L91">    private static final Logger LOGGER = LoggerFactory.getLogger(Bootstrapper.class);</span>
<span class="nc" id="L92">    private static final Map&lt;String, File&gt; TMP_EXTRACTED_FILES = new HashMap&lt;&gt;();</span>

    private static Undertow server;
<span class="nc" id="L95">    private static GracefulShutdownHandler shutdownHandler = null;</span>
    private static Configuration configuration;
    private static Path pidFilePath;

    /**
     * main method
     *
     * @param args command line arguments
     */
    public static void main(final String[] args) {

        try {
            // read configuration silently, to avoid logging before initializing the logger
<span class="nc" id="L108">            configuration = FileUtils.getConfiguration(args, true);</span>
<span class="nc" id="L109">        } catch (ConfigurationException ex) {</span>
<span class="nc" id="L110">            LOGGER.error(ex.getMessage() + &quot;, exiting...&quot;, ex);</span>
<span class="nc" id="L111">            stopServer(false);</span>
<span class="nc" id="L112">            System.exit(-1);</span>
<span class="nc" id="L113">        }</span>

<span class="nc" id="L115">        Daemon d = null;</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (!OSChecker.isWindows()) {</span>
<span class="nc" id="L118">            d = new Daemon.WithoutChdir();</span>

            // pid file name include the hash of the configuration file so that for each configuration we can have just one instance running
            // If we proceed we'd get a BindException for same port being already used by the running instance
<span class="nc" id="L122">            pidFilePath = FileUtils.getPidFilePath(FileUtils.getFileAbsoultePathHash(FileUtils.getConfigurationFilePath(args)));</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (Files.exists(pidFilePath)) {</span>
<span class="nc" id="L125">                LOGGER.info(&quot;Starting RESTHeart ********************************************&quot;);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                LOGGER.error(&quot;This instance is already running, exiting. {}&quot;, FileUtils.getConfigurationFilePath(args) == null ? &quot;No configuration file specified&quot; : &quot;Configuration file is &quot; + FileUtils.getConfigurationFilePath(args));</span>
<span class="nc" id="L127">                LOGGER.error(&quot;Running instance pid is {}&quot;, FileUtils.getPidFromFile(pidFilePath));</span>
<span class="nc" id="L128">                LOGGER.error(&quot;If it is not actually running, manually remove the pid file {} and retry&quot;, pidFilePath);</span>
<span class="nc" id="L129">                LOGGER.info(&quot;Exiting *********************************************&quot;);</span>

                // do not stopServer() here, since this might delete other running instace pid file and tmp resources
<span class="nc" id="L132">                System.exit(-1);</span>
            }
        }

<span class="nc" id="L136">        initLogging(args, d);</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (!OSChecker.isWindows()) {</span>
<span class="nc" id="L139">            d = new Daemon.WithoutChdir();</span>
        } else {
<span class="nc" id="L141">            LOGGER.info(&quot;Starting RESTHeart ********************************************&quot;);</span>

            try {
<span class="nc" id="L144">                configuration = FileUtils.getConfiguration(args);</span>
<span class="nc" id="L145">            } catch (ConfigurationException ex) {</span>
<span class="nc" id="L146">                LOGGER.error(ex.getMessage() + &quot;, exiting...&quot;, ex);</span>
<span class="nc" id="L147">                stopServer(false);</span>
<span class="nc" id="L148">                System.exit(-1);</span>
<span class="nc" id="L149">            }</span>

<span class="nc bnc" id="L151" title="All 4 branches missed.">            if (shouldDemonize(args) &amp;&amp; OSChecker.isWindows()) {</span>
<span class="nc" id="L152">                LOGGER.warn(&quot;Fork is not supported on Windows&quot;);</span>
            }

<span class="nc" id="L155">            logLoggingConfiguration(args, d);</span>
        }

        // we are not on Windows and this process is not daemonized
<span class="nc bnc" id="L159" title="All 4 branches missed.">        if (d != null &amp;&amp; !d.isDaemonized()) {</span>
<span class="nc" id="L160">            LOGGER.info(&quot;Starting RESTHeart ********************************************&quot;);</span>

            try {
<span class="nc" id="L163">                configuration = FileUtils.getConfiguration(args);</span>
<span class="nc" id="L164">            } catch (ConfigurationException ex) {</span>
<span class="nc" id="L165">                LOGGER.error(ex.getMessage() + &quot;, exiting...&quot;, ex);</span>
<span class="nc" id="L166">                stopServer(false);</span>
<span class="nc" id="L167">                System.exit(-1);</span>
<span class="nc" id="L168">            }</span>

            // we have to fork, this is done later by demonizeInCase(args, d), now just log some message
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (shouldDemonize(args)) {</span>
<span class="nc" id="L172">                LOGGER.info(&quot;Stopping logging to console&quot;);</span>
<span class="nc" id="L173">                LOGGER.info(&quot;Logging to {} with level {}&quot;, configuration.getLogFilePath(), configuration.getLogLevel());</span>
<span class="nc" id="L174">                LOGGER.info(&quot;RESTHeart forked **********************************************&quot;);</span>
            } // we don't have to fork, let's create the pid file (otherwise done by Daemon.init() call in demonizeInCase())
            else {
<span class="nc" id="L177">                LOGGER.info(&quot;Creating pid file {}&quot;, pidFilePath);</span>
<span class="nc" id="L178">                FileUtils.createPidFile(pidFilePath);</span>
            }

<span class="nc" id="L181">            logLoggingConfiguration(args, d);</span>
        }

        // we are not on windows and this process is daemonized
<span class="nc bnc" id="L185" title="All 4 branches missed.">        if (d != null &amp;&amp; d.isDaemonized()) {</span>
<span class="nc" id="L186">            pidFilePath = FileUtils.getPidFilePath(FileUtils.getFileAbsoultePathHash(FileUtils.getConfigurationFilePath(args)));</span>

<span class="nc" id="L188">            LOGGER.info(&quot;Forking RESTHeart ********************************************&quot;);</span>

<span class="nc" id="L190">            logLoggingConfiguration(args, d);</span>

            // re-read configuration, to have warnings and errors logged to file
            try {
<span class="nc" id="L194">                configuration = FileUtils.getConfiguration(args);</span>
<span class="nc" id="L195">            } catch (ConfigurationException ex) {</span>
<span class="nc" id="L196">                LOGGER.error(ex.getMessage() + &quot;, exiting...&quot;, ex);</span>
<span class="nc" id="L197">                stopServer(false);</span>
<span class="nc" id="L198">                System.exit(-1);</span>
<span class="nc" id="L199">            }</span>

            try {
<span class="nc" id="L202">                LOGGER.info(&quot;pid file {}&quot;, pidFilePath);</span>
<span class="nc" id="L203">                d.init(pidFilePath.toString());</span>
<span class="nc" id="L204">            } catch (Exception ex) {</span>
<span class="nc" id="L205">                LOGGER.error(&quot;Error writing pid file to {}&quot;, pidFilePath, ex);</span>
<span class="nc" id="L206">            }</span>
        }

<span class="nc" id="L209">        demonizeInCase(args, d);</span>
<span class="nc" id="L210">        startServer();</span>
<span class="nc" id="L211">    }</span>

    /**
     * Startups the RESTHeart server
     *
     * @param confFilePath the path of the configuration file
     */
    public static void startup(final String confFilePath) {
        try {
<span class="nc" id="L220">            configuration = FileUtils.getConfiguration(new String[]{confFilePath});</span>
<span class="nc" id="L221">        } catch (ConfigurationException ex) {</span>
<span class="nc" id="L222">            LOGGER.error(ex.getMessage() + &quot;, exiting...&quot;, ex);</span>
<span class="nc" id="L223">            stopServer(false);</span>
<span class="nc" id="L224">            System.exit(-1);</span>
<span class="nc" id="L225">        }</span>

<span class="nc" id="L227">        startServer();</span>
<span class="nc" id="L228">    }</span>

    /**
     * Shutdown the RESTHeart server
     */
    public static void shutdown() {
<span class="nc" id="L234">        stopServer(false);</span>
<span class="nc" id="L235">    }</span>

    private static void initLogging(final String[] args, final Daemon d) {
<span class="nc" id="L238">        LoggingInitializer.setLogLevel(configuration.getLogLevel());</span>

<span class="nc bnc" id="L240" title="All 4 branches missed.">        if (d != null &amp;&amp; d.isDaemonized()) {</span>
<span class="nc" id="L241">            LoggingInitializer.stopConsoleLogging();</span>
<span class="nc" id="L242">            LoggingInitializer.startFileLogging(configuration.getLogFilePath());</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        } else if (!shouldDemonize(args)) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (!configuration.isLogToConsole()) {</span>
<span class="nc" id="L245">                LoggingInitializer.stopConsoleLogging();</span>
            }
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (configuration.isLogToFile()) {</span>
<span class="nc" id="L248">                LoggingInitializer.startFileLogging(configuration.getLogFilePath());</span>
            }
        }
<span class="nc" id="L251">    }</span>

    private static void logLoggingConfiguration(final String[] args, final Daemon d) {
<span class="nc bnc" id="L254" title="All 4 branches missed.">        if (d == null || !d.isDaemonized()) {</span>
<span class="nc" id="L255">            return;</span>
        }

<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (!shouldDemonize(args)) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (!configuration.isLogToConsole()) {</span>
<span class="nc" id="L260">                LOGGER.info(&quot;Stop logging to console &quot;);</span>
<span class="nc" id="L261">                LOGGER.info(&quot;***************************************************************&quot;);</span>
            } else {
<span class="nc" id="L263">                LOGGER.info(&quot;Logging to console with level {}&quot;, configuration.getLogLevel());</span>
            }

<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (configuration.isLogToFile()) {</span>
<span class="nc" id="L267">                LOGGER.info(&quot;Logging to {} with level {}&quot;, configuration.getLogFilePath(), configuration.getLogLevel());</span>
            }
        }
<span class="nc" id="L270">    }</span>

    private static boolean shouldDemonize(final String[] args) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        for (String arg : args) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (arg.equals(&quot;--fork&quot;)) {</span>
<span class="nc" id="L275">                return true;</span>
            }
        }

<span class="nc" id="L279">        return false;</span>
    }

    private static void demonizeInCase(final String[] args, Daemon d) {
<span class="nc bnc" id="L283" title="All 8 branches missed.">        if (d == null || d.isDaemonized() || args == null || args.length &lt; 1) {</span>
<span class="nc" id="L284">            return;</span>
        }

<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (shouldDemonize(args)) {</span>
            // Daemon only works on POSIX OSes
<span class="nc" id="L289">            final boolean isPosix = FileSystems.getDefault().supportedFileAttributeViews().contains(&quot;posix&quot;);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (isPosix) {</span>
                try {
<span class="nc" id="L292">                    d.daemonize();</span>
<span class="nc" id="L293">                    stopServer(true);</span>
<span class="nc" id="L294">                    System.exit(0);</span>
<span class="nc" id="L295">                } catch (Exception ex) {</span>
<span class="nc" id="L296">                    LOGGER.warn(&quot;Unable to fork process. Note that forking is only supported on Linux (x86, amd64), Solaris (x86, amd64, sparc, sparcv9) and Mac OS X&quot;, ex);</span>
<span class="nc" id="L297">                }</span>
            } else {
<span class="nc" id="L299">                LOGGER.info(&quot;Unable to fork process, this is only supported on POSIX compliant OSes&quot;);</span>
            }
        }
<span class="nc" id="L302">    }</span>

    private static void startServer() {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (RESTHEART_VERSION != null) {</span>
<span class="nc" id="L306">            LOGGER.info(&quot;RESTHeart version {}&quot;, RESTHEART_VERSION);</span>
        }

<span class="nc" id="L309">        String mongoHosts = configuration.getMongoServers().stream()</span>
<span class="nc" id="L310">                .map(s -&gt; s.get(Configuration.MONGO_HOST_KEY) + &quot;:&quot; + s.get(Configuration.MONGO_PORT_KEY) + &quot; &quot;)</span>
<span class="nc" id="L311">                .reduce(&quot;&quot;, String::concat);</span>

<span class="nc" id="L313">        LOGGER.info(&quot;Initializing MongoDB connection pool to {}&quot;, mongoHosts);</span>

        try {
<span class="nc" id="L316">            MongoDBClientSingleton.init(configuration);</span>
<span class="nc" id="L317">            LOGGER.info(&quot;MongoDB connection pool initialized&quot;);</span>
<span class="nc" id="L318">        } catch (Throwable t) {</span>
<span class="nc" id="L319">            LOGGER.error(&quot;Error connecting to MongoDB. exiting..&quot;, t);</span>
<span class="nc" id="L320">            stopServer(false);</span>
<span class="nc" id="L321">            System.exit(-1);</span>
<span class="nc" id="L322">        }</span>

        try {
<span class="nc" id="L325">            startCoreSystem();</span>
<span class="nc" id="L326">        } catch (Throwable t) {</span>
<span class="nc" id="L327">            LOGGER.error(&quot;Error starting RESTHeart. Exiting...&quot;, t);</span>
<span class="nc" id="L328">            stopServer(false);</span>
<span class="nc" id="L329">            System.exit(-2);</span>
<span class="nc" id="L330">        }</span>

<span class="nc" id="L332">        Runtime.getRuntime().addShutdownHook(new Thread() {</span>
            @Override
            public void run() {
<span class="nc" id="L335">                stopServer(false);</span>
<span class="nc" id="L336">            }</span>
        });

<span class="nc" id="L339">        LOGGER.info(&quot;RESTHeart started **********************************************&quot;);</span>
<span class="nc" id="L340">    }</span>

    private static void stopServer(boolean silent) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (!silent) {</span>
<span class="nc" id="L344">            LOGGER.info(&quot;Stopping RESTHeart...&quot;);</span>
        }

<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (shutdownHandler != null) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (!silent) {</span>
<span class="nc" id="L349">                LOGGER.info(&quot;Waiting for pending request to complete (up to 1 minute)...&quot;);</span>
            }
            try {
<span class="nc" id="L352">                shutdownHandler.shutdown();</span>
<span class="nc" id="L353">                shutdownHandler.awaitShutdown(60 * 1000); // up to 1 minute</span>
<span class="nc" id="L354">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L355">                LOGGER.error(&quot;Error while waiting for pending request to complete&quot;, ie);</span>
<span class="nc" id="L356">            }</span>
        }

<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (server != null) {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (!silent) {</span>
<span class="nc" id="L361">                LOGGER.info(&quot;Stopping the Undertow server...&quot;);</span>
            }
            try {
<span class="nc" id="L364">                server.stop();</span>
<span class="nc" id="L365">            } catch (Throwable t) {</span>
<span class="nc" id="L366">                LOGGER.error(&quot;Error stopping the Undertow server&quot;, t);</span>
<span class="nc" id="L367">            }</span>
        }

        try {
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (!silent) {</span>
<span class="nc" id="L372">                LOGGER.info(&quot;Flushing and closing the MongoDB client...&quot;);</span>
            }
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (MongoDBClientSingleton.isInitialized()) {</span>
<span class="nc" id="L375">                MongoClient client = MongoDBClientSingleton.getInstance().getClient();</span>
<span class="nc" id="L376">                client.fsync(false);</span>
<span class="nc" id="L377">                client.close();</span>
            }
<span class="nc" id="L379">        } catch (Throwable t) {</span>
<span class="nc" id="L380">            LOGGER.error(&quot;Error flushing and closing the MongoDB client&quot;, t);</span>
<span class="nc" id="L381">        }</span>

<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (pidFilePath != null) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            if (!silent) {</span>
<span class="nc" id="L385">                LOGGER.info(&quot;Removing the pid file {}&quot;, pidFilePath.toString());</span>
            }
            try {
<span class="nc" id="L388">                Files.deleteIfExists(pidFilePath);</span>
<span class="nc" id="L389">            } catch (IOException ex) {</span>
<span class="nc" id="L390">                LOGGER.error(&quot;Can't delete pid file {}&quot;, pidFilePath.toString(), ex);</span>
<span class="nc" id="L391">            }</span>
        }

<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (!silent) {</span>
<span class="nc" id="L395">            LOGGER.info(&quot;Cleaning up temporary directories...&quot;);</span>
        }
<span class="nc" id="L397">        TMP_EXTRACTED_FILES.keySet().forEach(k -&gt; {</span>
            try {
<span class="nc" id="L399">                ResourcesExtractor.deleteTempDir(k, TMP_EXTRACTED_FILES.get(k));</span>
<span class="nc" id="L400">            } catch (URISyntaxException | IOException ex) {</span>
<span class="nc" id="L401">                LOGGER.error(&quot;Error cleaning up temporary directory {}&quot;, TMP_EXTRACTED_FILES.get(k).toString(), ex);</span>
<span class="nc" id="L402">            }</span>
<span class="nc" id="L403">        });</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (!silent) {</span>
<span class="nc" id="L406">            LOGGER.info(&quot;RESTHeart stopped *********************************************&quot;);</span>
        }
<span class="nc" id="L408">    }</span>

    private static void startCoreSystem() {
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (configuration == null) {</span>
<span class="nc" id="L412">            LOGGER.error(&quot;No configuration found. exiting..&quot;);</span>
<span class="nc" id="L413">            stopServer(false);</span>
<span class="nc" id="L414">            System.exit(-1);</span>
        }

<span class="nc bnc" id="L417" title="All 6 branches missed.">        if (!configuration.isHttpsListener() &amp;&amp; !configuration.isHttpListener() &amp;&amp; !configuration.isAjpListener()) {</span>
<span class="nc" id="L418">            LOGGER.error(&quot;No listener specified. exiting..&quot;);</span>
<span class="nc" id="L419">            stopServer(false);</span>
<span class="nc" id="L420">            System.exit(-1);</span>
        }

<span class="nc" id="L423">        IdentityManager identityManager = null;</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (configuration.getIdmImpl() == null) {</span>
<span class="nc" id="L426">            LOGGER.warn(&quot;***** No identity manager specified. authentication disabled.&quot;);</span>
<span class="nc" id="L427">            identityManager = null;</span>

        } else {
            try {
<span class="nc" id="L431">                Object idm = Class.forName(configuration.getIdmImpl())</span>
<span class="nc" id="L432">                        .getConstructor(Map.class)</span>
<span class="nc" id="L433">                        .newInstance(configuration.getIdmArgs());</span>
<span class="nc" id="L434">                identityManager = (IdentityManager) idm;</span>
<span class="nc" id="L435">            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {</span>
<span class="nc" id="L436">                LOGGER.error(&quot;Error configuring idm implementation {}&quot;, configuration.getIdmImpl(), ex);</span>
<span class="nc" id="L437">                stopServer(false);</span>
<span class="nc" id="L438">                System.exit(-3);</span>
<span class="nc" id="L439">            }</span>
        }

<span class="nc" id="L442">        AccessManager accessManager = null;</span>

<span class="nc bnc" id="L444" title="All 4 branches missed.">        if (configuration.getAmImpl() == null &amp;&amp; configuration.getIdmImpl() != null) {</span>
<span class="nc" id="L445">            LOGGER.warn(&quot;***** no access manager specified. authenticated users can do anything.&quot;);</span>
<span class="nc" id="L446">            accessManager = new FullAccessManager();</span>
<span class="nc bnc" id="L447" title="All 4 branches missed.">        } else if (configuration.getAmImpl() == null &amp;&amp; configuration.getIdmImpl() == null) {</span>
<span class="nc" id="L448">            LOGGER.warn(&quot;***** No access manager specified. users can do anything.&quot;);</span>
<span class="nc" id="L449">            accessManager = new FullAccessManager();</span>

        } else {
            try {
<span class="nc" id="L453">                Object am = Class.forName(configuration.getAmImpl())</span>
<span class="nc" id="L454">                        .getConstructor(Map.class)</span>
<span class="nc" id="L455">                        .newInstance(configuration.getAmArgs());</span>
<span class="nc" id="L456">                accessManager = (AccessManager) am;</span>
<span class="nc" id="L457">            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {</span>
<span class="nc" id="L458">                LOGGER.error(&quot;Error configuring acess manager implementation {}&quot;, configuration.getAmImpl(), ex);</span>
<span class="nc" id="L459">                stopServer(false);</span>
<span class="nc" id="L460">                System.exit(-3);</span>
<span class="nc" id="L461">            }</span>
        }

<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (configuration.isAuthTokenEnabled()) {</span>
<span class="nc" id="L465">            LOGGER.info(&quot;Token based authentication enabled with token TTL {} minutes&quot;, configuration.getAuthTokenTtl());</span>
        }

<span class="nc" id="L468">        SSLContext sslContext = null;</span>

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (getConfiguration().isUseEmbeddedKeystore()) {</span>
<span class="nc" id="L475">                char[] storepass = &quot;restheart&quot;.toCharArray();</span>
<span class="nc" id="L476">                char[] keypass = &quot;restheart&quot;.toCharArray();</span>

<span class="nc" id="L478">                String storename = &quot;rakeystore.jks&quot;;</span>

<span class="nc" id="L480">                sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="nc" id="L481">                kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L482">                ks = KeyStore.getInstance(&quot;JKS&quot;);</span>
<span class="nc" id="L483">                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);</span>

<span class="nc" id="L485">                kmf.init(ks, keypass);</span>

<span class="nc" id="L487">                sslContext.init(kmf.getKeyManagers(), null, null);</span>
<span class="nc" id="L488">            } else {</span>
<span class="nc" id="L489">                sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="nc" id="L490">                kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L491">                ks = KeyStore.getInstance(&quot;JKS&quot;);</span>

<span class="nc" id="L493">                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {</span>
<span class="nc" id="L494">                    ks.load(fis, configuration.getKeystorePassword().toCharArray());</span>

<span class="nc" id="L496">                    kmf.init(ks, configuration.getCertPassword().toCharArray());</span>
<span class="nc" id="L497">                    sslContext.init(kmf.getKeyManagers(), null, null);</span>
<span class="nc bnc" id="L498" title="All 8 branches missed.">                }</span>
            }
<span class="nc" id="L500">        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {</span>
<span class="nc" id="L501">            LOGGER.error(&quot;Couldn't start RESTHeart, error with specified keystore. exiting..&quot;, ex);</span>
<span class="nc" id="L502">            stopServer(false);</span>
<span class="nc" id="L503">            System.exit(-1);</span>
<span class="nc" id="L504">        } catch (FileNotFoundException ex) {</span>
<span class="nc" id="L505">            LOGGER.error(&quot;Couldn't start RESTHeart, keystore file not found. exiting..&quot;, ex);</span>
<span class="nc" id="L506">            stopServer(false);</span>
<span class="nc" id="L507">            System.exit(-1);</span>
<span class="nc" id="L508">        } catch (IOException ex) {</span>
<span class="nc" id="L509">            LOGGER.error(&quot;Couldn't start RESTHeart, error reading the keystore file. exiting..&quot;, ex);</span>
<span class="nc" id="L510">            stopServer(false);</span>
<span class="nc" id="L511">            System.exit(-1);</span>
<span class="nc" id="L512">        }</span>

<span class="nc" id="L514">        Builder builder = Undertow.builder();</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (configuration.isHttpsListener()) {</span>
<span class="nc" id="L517">            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);</span>
<span class="nc" id="L518">            LOGGER.info(&quot;HTTPS listener bound at {}:{}&quot;, configuration.getHttpsHost(), configuration.getHttpsPort());</span>
        }

<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (configuration.isHttpListener()) {</span>
<span class="nc" id="L522">            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());</span>
<span class="nc" id="L523">            LOGGER.info(&quot;HTTP listener bound at {}:{}&quot;, configuration.getHttpHost(), configuration.getHttpPort());</span>
        }

<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (configuration.isAjpListener()) {</span>
<span class="nc" id="L527">            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());</span>
<span class="nc" id="L528">            LOGGER.info(&quot;Ajp listener bound at {}:{}&quot;, configuration.getAjpHost(), configuration.getAjpPort());</span>
        }

<span class="nc" id="L531">        LocalCachesSingleton.init(configuration);</span>

<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (configuration.isLocalCacheEnabled()) {</span>
<span class="nc" id="L534">            LOGGER.info(&quot;Local cache for db and collection properties enabled&quot;);</span>
        } else {
<span class="nc" id="L536">            LOGGER.info(&quot;Local cache for db and collection properties not enabled&quot;);</span>
        }

<span class="nc" id="L539">        shutdownHandler = getHandlersPipe(identityManager, accessManager);</span>

<span class="nc" id="L541">        builder</span>
<span class="nc" id="L542">                .setIoThreads(configuration.getIoThreads())</span>
<span class="nc" id="L543">                .setWorkerThreads(configuration.getWorkerThreads())</span>
<span class="nc" id="L544">                .setDirectBuffers(configuration.isDirectBuffers())</span>
<span class="nc" id="L545">                .setBufferSize(configuration.getBufferSize())</span>
<span class="nc" id="L546">                .setBuffersPerRegion(configuration.getBuffersPerRegion())</span>
<span class="nc" id="L547">                .setHandler(shutdownHandler);</span>

<span class="nc" id="L549">        builder.build().start();</span>
<span class="nc" id="L550">    }</span>

    private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager, final AccessManager accessManager) {
<span class="nc" id="L553">        PipedHttpHandler coreHandlerChain</span>
                = new DbPropsInjectorHandler(
                        new CollectionPropsInjectorHandler(
                                new RequestDispacherHandler()
                        ));

<span class="nc" id="L559">        PathHandler paths = path();</span>

<span class="nc" id="L561">        configuration.getMongoMounts().stream().forEach(m -&gt; {</span>
<span class="nc" id="L562">            String url = (String) m.get(Configuration.MONGO_MOUNT_WHERE_KEY);</span>
<span class="nc" id="L563">            String db = (String) m.get(Configuration.MONGO_MOUNT_WHAT_KEY);</span>

<span class="nc" id="L565">            paths.addPrefixPath(url,</span>
                    new CORSHandler(
                            new RequestContextInjectorHandler(url, db,
                                    new OptionsHandler(
                                            new BodyInjectorHandler(
                                                    new SecurityHandlerDispacher(coreHandlerChain, identityManager, accessManager))))
                    ));

<span class="nc" id="L573">            LOGGER.info(&quot;URL {} bound to MongoDB resource {}&quot;, url, db);</span>
<span class="nc" id="L574">        });</span>

<span class="nc" id="L576">        pipeStaticResourcesHandlers(configuration, paths, identityManager, accessManager);</span>

<span class="nc" id="L578">        pipeApplicationLogicHandlers(configuration, paths, identityManager, accessManager);</span>

        // pipe the auth tokens invalidation handler
<span class="nc" id="L581">        paths.addPrefixPath(&quot;/_authtokens&quot;, new CORSHandler(new SecurityHandlerDispacher(new AuthTokenHandler(), identityManager, new FullAccessManager())));</span>

<span class="nc" id="L583">        return new GracefulShutdownHandler(</span>
<span class="nc" id="L584">                new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),</span>
                        new AllowedMethodsHandler(
                                new BlockingHandler(
                                        new GzipEncodingHandler(
                                                new ErrorHandler(
                                                        new HttpContinueAcceptingHandler(paths)
<span class="nc" id="L590">                                                ), configuration.isForceGzipEncoding()</span>
                                        )
                                ), // allowed methods
<span class="nc" id="L593">                                HttpString.tryFromString(RequestContext.METHOD.GET.name()),</span>
<span class="nc" id="L594">                                HttpString.tryFromString(RequestContext.METHOD.POST.name()),</span>
<span class="nc" id="L595">                                HttpString.tryFromString(RequestContext.METHOD.PUT.name()),</span>
<span class="nc" id="L596">                                HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),</span>
<span class="nc" id="L597">                                HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),</span>
<span class="nc" id="L598">                                HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name())</span>
                        )
                )
        );
    }

    private static void pipeStaticResourcesHandlers(
            final Configuration conf,
            final PathHandler paths,
            final IdentityManager identityManager,
            final AccessManager accessManager) {
        // pipe the static resources specified in the configuration file
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (conf.getStaticResourcesMounts() != null) {</span>
<span class="nc" id="L611">            conf.getStaticResourcesMounts().stream().forEach(sr -&gt; {</span>
                try {
<span class="nc" id="L613">                    String path = (String) sr.get(Configuration.STATIC_RESOURCES_MOUNT_WHAT_KEY);</span>
<span class="nc" id="L614">                    String where = (String) sr.get(Configuration.STATIC_RESOURCES_MOUNT_WHERE_KEY);</span>
<span class="nc" id="L615">                    String welcomeFile = (String) sr.get(Configuration.STATIC_RESOURCES_MOUNT_WELCOME_FILE_KEY);</span>
<span class="nc" id="L616">                    boolean embedded = (Boolean) sr.get(Configuration.STATIC_RESOURCES_MOUNT_EMBEDDED_KEY);</span>
<span class="nc" id="L617">                    boolean secured = (Boolean) sr.get(Configuration.STATIC_RESOURCES_MOUNT_SECURED_KEY);</span>

<span class="nc bnc" id="L619" title="All 4 branches missed.">                    if (where == null || !where.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L620">                        LOGGER.error(&quot;Cannot bind static resources to {}. parameter 'where' must start with /&quot;, where);</span>
<span class="nc" id="L621">                        return;</span>
                    }

<span class="nc bnc" id="L624" title="All 2 branches missed.">                    if (welcomeFile == null) {</span>
<span class="nc" id="L625">                        welcomeFile = &quot;index.html&quot;;</span>
                    }

                    File file;

<span class="nc bnc" id="L630" title="All 2 branches missed.">                    if (embedded) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                        if (path.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L632">                            LOGGER.error(&quot;Cannot bind embedded static resources to {}. parameter 'where'&quot;</span>
                                    + &quot;cannot start with /. the path is relative to the jar root dir or classpath directory&quot;, where);
<span class="nc" id="L634">                            return;</span>
                        }

                        try {
<span class="nc" id="L638">                            file = ResourcesExtractor.extract(path);</span>

<span class="nc bnc" id="L640" title="All 2 branches missed.">                            if (ResourcesExtractor.isResourceInJar(path)) {</span>
<span class="nc" id="L641">                                TMP_EXTRACTED_FILES.put(path, file);</span>
<span class="nc" id="L642">                                LOGGER.info(&quot;Embedded static resources {} extracted in {}&quot;, path, file.toString());</span>
                            }
<span class="nc" id="L644">                        } catch (URISyntaxException | IOException ex) {</span>
<span class="nc" id="L645">                            LOGGER.error(&quot;Error extracting embedded static resource {}&quot;, path, ex);</span>
<span class="nc" id="L646">                            return;</span>
<span class="nc" id="L647">                        } catch (IllegalStateException ex) {</span>
<span class="nc" id="L648">                            LOGGER.error(&quot;Error extracting embedded static resource {}&quot;, path, ex);</span>

<span class="nc bnc" id="L650" title="All 2 branches missed.">                            if (&quot;browser&quot;.equals(path)) {</span>
<span class="nc" id="L651">                                LOGGER.error(&quot;**** Did you downloaded the browser submodule before building?&quot;);</span>
<span class="nc" id="L652">                                LOGGER.error(&quot;**** to fix, run this command: $ git submodule update --init --recursive&quot;);</span>
                            }
<span class="nc" id="L654">                            return;</span>

<span class="nc" id="L656">                        }</span>
                    } else {
<span class="nc bnc" id="L658" title="All 2 branches missed.">                        if (!path.startsWith(&quot;/&quot;)) {</span>
                            // this is to allow specifying the configuration file path relative to the jar (also working when running from classes)
<span class="nc" id="L660">                            URL location = Bootstrapper.class</span>
<span class="nc" id="L661">                                    .getProtectionDomain().getCodeSource().getLocation();</span>
<span class="nc" id="L662">                            File locationFile = new File(location.getPath());</span>
<span class="nc" id="L663">                            file = new File(locationFile.getParent() + File.separator + path);</span>
<span class="nc" id="L664">                        } else {</span>
<span class="nc" id="L665">                            file = new File(path);</span>
                        }
                    }

<span class="nc" id="L669">                    ResourceHandler handler = resource(new FileResourceManager(file, 3))</span>
<span class="nc" id="L670">                            .addWelcomeFiles(welcomeFile)</span>
<span class="nc" id="L671">                            .setDirectoryListingEnabled(false);</span>

<span class="nc bnc" id="L673" title="All 2 branches missed.">                    if (secured) {</span>
<span class="nc" id="L674">                        paths.addPrefixPath(where,</span>
                                new SecurityHandlerDispacher(
                                        new PipedWrappingHandler(null, handler), identityManager, accessManager));
                    } else {
<span class="nc" id="L678">                        paths.addPrefixPath(where, handler);</span>
                    }

<span class="nc" id="L681">                    LOGGER.info(&quot;URL {} bound to static resources {}. access manager: {}&quot;, where, path, secured);</span>

<span class="nc" id="L683">                } catch (Throwable t) {</span>
<span class="nc" id="L684">                    LOGGER.error(&quot;Cannot bind static resources to {}&quot;, sr.get(Configuration.STATIC_RESOURCES_MOUNT_WHERE_KEY), t);</span>
<span class="nc" id="L685">                }</span>
<span class="nc" id="L686">            });</span>
        }
<span class="nc" id="L688">    }</span>

    private static void pipeApplicationLogicHandlers(
            final Configuration conf,
            final PathHandler paths,
            final IdentityManager identityManager,
            final AccessManager accessManager) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (conf.getApplicationLogicMounts() != null) {</span>
<span class="nc" id="L696">            conf.getApplicationLogicMounts().stream().forEach(al -&gt; {</span>
                try {
<span class="nc" id="L698">                    String alClazz = (String) al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHAT_KEY);</span>
<span class="nc" id="L699">                    String alWhere = (String) al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY);</span>
<span class="nc" id="L700">                    boolean alSecured = (Boolean) al.get(Configuration.APPLICATION_LOGIC_MOUNT_SECURED_KEY);</span>
<span class="nc" id="L701">                    Object alArgs = al.get(Configuration.APPLICATION_LOGIC_MOUNT_ARGS_KEY);</span>

<span class="nc bnc" id="L703" title="All 4 branches missed.">                    if (alWhere == null || !alWhere.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L704">                        LOGGER.error(&quot;Cannot pipe application logic handler {}. parameter 'where' must start with /&quot;, alWhere);</span>
<span class="nc" id="L705">                        return;</span>
                    }

<span class="nc bnc" id="L708" title="All 4 branches missed.">                    if (alArgs != null &amp;&amp; !(alArgs instanceof Map)) {</span>
<span class="nc" id="L709">                        LOGGER.error(&quot;Cannot pipe application logic handler {}.&quot;</span>
<span class="nc" id="L710">                                + &quot;args are not defined as a map. it is a &quot;, alWhere, alWhere.getClass());</span>
<span class="nc" id="L711">                        return;</span>

                    }

<span class="nc" id="L715">                    Object o = Class.forName(alClazz)</span>
<span class="nc" id="L716">                            .getConstructor(PipedHttpHandler.class, Map.class)</span>
<span class="nc" id="L717">                            .newInstance(null, (Map) alArgs);</span>

<span class="nc bnc" id="L719" title="All 2 branches missed.">                    if (o instanceof ApplicationLogicHandler) {</span>
<span class="nc" id="L720">                        ApplicationLogicHandler alHandler = (ApplicationLogicHandler) o;</span>

<span class="nc" id="L722">                        PipedHttpHandler handler = new RequestContextInjectorHandler(&quot;/_logic&quot;, &quot;*&quot;, alHandler);</span>

<span class="nc bnc" id="L724" title="All 2 branches missed.">                        if (alSecured) {</span>
<span class="nc" id="L725">                            paths.addPrefixPath(&quot;/_logic&quot; + alWhere, new CORSHandler(new SecurityHandlerDispacher(handler, identityManager, accessManager)));</span>
                        } else {
<span class="nc" id="L727">                            paths.addPrefixPath(&quot;/_logic&quot; + alWhere, new CORSHandler(new SecurityHandlerDispacher(handler, identityManager, new FullAccessManager())));</span>
                        }

<span class="nc" id="L730">                        LOGGER.info(&quot;URL {} bound to application logic handler {}.&quot;</span>
<span class="nc" id="L731">                                + &quot; access manager: {}&quot;, &quot;/_logic&quot; + alWhere, alClazz, alSecured);</span>
<span class="nc" id="L732">                    } else {</span>
<span class="nc" id="L733">                        LOGGER.error(&quot;Cannot pipe application logic handler {}.&quot;</span>
                                + &quot; class {} does not extend ApplicationLogicHandler&quot;, alWhere, alClazz);
                    }

<span class="nc" id="L737">                } catch (Throwable t) {</span>
<span class="nc" id="L738">                    LOGGER.error(&quot;Cannot pipe application logic handler {}&quot;,</span>
<span class="nc" id="L739">                            al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY), t);</span>
<span class="nc" id="L740">                }</span>
<span class="nc" id="L741">            }</span>
            );
        }
<span class="nc" id="L744">    }</span>

    /**
     * @return the conf
     */
    public static Configuration getConfiguration() {
<span class="nc" id="L750">        return configuration;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>