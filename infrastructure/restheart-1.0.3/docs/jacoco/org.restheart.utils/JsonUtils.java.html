<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JsonUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Restheart</a> &gt; <a href="index.source.html" class="el_package">org.restheart.utils</a> &gt; <span class="el_source">JsonUtils.java</span></div><h1>JsonUtils.java</h1><pre class="source lang-java linenums">/*
 * RESTHeart - the data REST API server
 * Copyright (C) SoftInstigate Srl
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.restheart.utils;

import com.mongodb.BasicDBList;
import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.util.JSONSerializers;
import com.mongodb.util.ObjectSerializer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.regex.Pattern;
import org.bson.types.BSONTimestamp;
import org.bson.types.Code;
import org.bson.types.MaxKey;
import org.bson.types.MinKey;
import org.bson.types.ObjectId;
import org.bson.types.Symbol;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author Andrea Di Cesare &lt;andrea@softinstigate.com&gt;
 */
public class JsonUtils {

<span class="fc" id="L46">    static final Logger LOGGER = LoggerFactory.getLogger(JsonUtils.class);</span>

<span class="fc" id="L48">    private static final ObjectSerializer serializer = JSONSerializers.getStrict();</span>

    /**
     *
     * @param bson the BSON object to serialize
     * @return the JSON strict mode representation of the BSON object
     *
     */
    public static String serialize(Object bson) {
<span class="nc" id="L57">        return serializer.serialize(bson);</span>
    }

    /**
     *
     * @param root the DBOject to extract properties from
     * @param path the path of the properties to extract
     * @return the List of Optional&lt;Object&gt;s extracted from root ojbect and identified by the path or null if path does
     * not exist
     *
     * @see org.restheart.test.unit.JsonUtilsTest form code examples
     *
     */
    public static List&lt;Optional&lt;Object&gt;&gt; getPropsFromPath(Object root, String path) throws IllegalArgumentException {
<span class="fc" id="L71">        String pathTokens[] = path.split(Pattern.quote(&quot;.&quot;));</span>

<span class="pc bpc" id="L73" title="3 of 6 branches missed.">        if (pathTokens == null || pathTokens.length == 0 || !pathTokens[0].equals(&quot;$&quot;)) {</span>
<span class="nc" id="L74">            throw new IllegalArgumentException(&quot;wrong path. it must use the . notation and start with $&quot;);</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        } else if (!(root instanceof BasicDBObject)) {</span>
<span class="nc" id="L76">            throw new IllegalArgumentException(&quot;wrong json. it must be an object&quot;);</span>
        } else {
<span class="fc" id="L78">            return _getPropsFromPath(root, pathTokens, pathTokens.length);</span>
        }
    }

    private static List&lt;Optional&lt;Object&gt;&gt; _getPropsFromPath(Object json, String[] pathTokens, int totalTokensLength) throws IllegalArgumentException {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (pathTokens == null) {</span>
<span class="nc" id="L84">            throw new IllegalArgumentException(&quot;pathTokens argument cannot be null&quot;);</span>
        }

        String pathToken;

<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (pathTokens.length &gt; 0) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (json == null) {</span>
<span class="fc" id="L91">                return null;</span>
            } else {

<span class="fc" id="L94">                pathToken = pathTokens[0];</span>

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">                if (&quot;&quot;.equals(pathToken)) {</span>
<span class="nc" id="L97">                    throw new IllegalArgumentException(&quot;wrong path &quot; + Arrays.toString(pathTokens) + &quot; path tokens cannot be empty strings&quot;);</span>
                }
            }
        } else {
<span class="fc" id="L101">            ArrayList&lt;Optional&lt;Object&gt;&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L102">            ret.add(Optional.ofNullable(json));</span>
<span class="fc" id="L103">            return ret;</span>
        }

        List&lt;Optional&lt;Object&gt;&gt; nested;

<span class="pc bpc" id="L108" title="3 of 14 branches missed.">        switch (pathToken) {</span>
            case &quot;$&quot;:
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">                if (!(json instanceof BasicDBObject)) {</span>
<span class="nc" id="L111">                    throw new IllegalArgumentException(&quot;wrong path &quot; + Arrays.toString(pathTokens) + &quot; at token &quot; + pathToken + &quot;; it should be an object but found &quot; + serializer.serialize(json));</span>
                }

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                if (pathTokens.length != totalTokensLength) {</span>
<span class="nc" id="L115">                    throw new IllegalArgumentException(&quot;wrong path &quot; + Arrays.toString(pathTokens) + &quot; at token &quot; + pathToken + &quot;; $ can only start the expression&quot;);</span>
                }

<span class="fc" id="L118">                return _getPropsFromPath(json, subpath(pathTokens), totalTokensLength);</span>
            case &quot;*&quot;:
<span class="fc bfc" id="L120" title="All 2 branches covered.">                if (!(json instanceof BasicDBObject)) {</span>
<span class="fc" id="L121">                    return null;</span>
                } else {
<span class="fc" id="L123">                    ArrayList&lt;Optional&lt;Object&gt;&gt; ret = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">                    for (String key : ((BasicDBObject) json).keySet()) {</span>
<span class="fc" id="L126">                        nested = _getPropsFromPath(((BasicDBObject) json).get(key), subpath(pathTokens), totalTokensLength);</span>

                        // only add null if subpath(pathTokens) was the last token
<span class="fc bfc" id="L129" title="All 4 branches covered.">                        if (nested == null &amp;&amp; pathTokens.length == 2) {</span>
<span class="fc" id="L130">                            ret.add(null);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">                        } else if (nested != null) {</span>
<span class="fc" id="L132">                            ret.addAll(nested);</span>
                        }
<span class="fc" id="L134">                    }</span>

<span class="fc" id="L136">                    return ret;</span>
                }
            case &quot;[*]&quot;:
<span class="fc bfc" id="L139" title="All 2 branches covered.">                if (!(json instanceof BasicDBList)) {</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                    if (json instanceof BasicDBObject) {</span>
                        // this might be the case of PATCHING an element array using the dot notation
                        // e.g. object.array.2
                        // if so, the array comes as an BasicDBObject with all numberic keys
                        // in any case, it might also be the object { &quot;object&quot;: { &quot;array&quot;: {&quot;2&quot;: xxx }}}

<span class="fc" id="L146">                        boolean allNumbericKeys = ((BasicDBObject) json).keySet().stream().allMatch(k -&gt; {</span>
                            try {
<span class="fc" id="L148">                                Integer.parseInt(k);</span>
<span class="fc" id="L149">                                return true;</span>
<span class="nc" id="L150">                            } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L151">                                return false;</span>
                            }
                        });

<span class="pc bpc" id="L155" title="1 of 2 branches missed.">                        if (allNumbericKeys) {</span>
<span class="fc" id="L156">                            ArrayList&lt;Optional&lt;Object&gt;&gt; ret = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">                            for (String key : ((BasicDBObject) json).keySet()) {</span>
<span class="fc" id="L159">                                nested = _getPropsFromPath(((BasicDBObject) json).get(key), subpath(pathTokens), totalTokensLength);</span>

                                // only add null if subpath(pathTokens) was the last token
<span class="pc bpc" id="L162" title="3 of 4 branches missed.">                                if (nested == null &amp;&amp; pathTokens.length == 2) {</span>
<span class="nc" id="L163">                                    ret.add(null);</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                                } else if (nested != null) {</span>
<span class="fc" id="L165">                                    ret.addAll(nested);</span>
                                }
<span class="fc" id="L167">                            }</span>

<span class="fc" id="L169">                            return ret;</span>
                        }
                    }

<span class="nc" id="L173">                    return null;</span>
                } else {
<span class="fc" id="L175">                    ArrayList&lt;Optional&lt;Object&gt;&gt; ret = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">                    if (!((BasicDBList) json).isEmpty()) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                        for (String key : ((BasicDBList) json).keySet()) {</span>
<span class="fc" id="L179">                            nested = _getPropsFromPath(((BasicDBList) json).get(key), subpath(pathTokens), totalTokensLength);</span>

                            // only add null if subpath(pathTokens) was the last token
<span class="fc bfc" id="L182" title="All 4 branches covered.">                            if (nested == null &amp;&amp; pathTokens.length == 2) {</span>
<span class="fc" id="L183">                                ret.add(null);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                            } else if (nested != null) {</span>
<span class="fc" id="L185">                                ret.addAll(nested);</span>
                            }
<span class="fc" id="L187">                        }</span>
                    }

<span class="fc" id="L190">                    return ret;</span>
                }
            default:
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (json instanceof BasicDBList) {</span>
<span class="nc" id="L194">                    throw new IllegalArgumentException(&quot;wrong path &quot; + pathFromTokens(pathTokens) + &quot; at token &quot; + pathToken + &quot;; it should be '[*]'&quot;);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                } else if (json instanceof BasicDBObject) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                    if (((DBObject) json).containsField(pathToken)) {</span>
<span class="fc" id="L197">                        return _getPropsFromPath(((DBObject) json).get(pathToken), subpath(pathTokens), totalTokensLength);</span>
                    } else {
<span class="fc" id="L199">                        return null;</span>
                    }
                } else {
<span class="fc" id="L202">                    return null;</span>
                }
        }
    }

    /**
     *
     * @param left the json path expression
     * @param right the json path expression
     *
     * @return true if the left json path is an acestor of the right path, i.e. left path selects a values set that
     * includes the one selected by the right path
     *
     * examples: ($, $.a) -&gt; true, ($.a, $.b) -&gt; false, ($.*, $.a) -&gt; true, ($.a.[*].c, $.a.0.c) -&gt; true, ($.a.[*],
     * $.a.b) -&gt; false
     *
     */
    public static boolean isAncestorPath(final String left, final String right) {
<span class="nc bnc" id="L220" title="All 4 branches missed.">        if (left == null || !left.startsWith(&quot;$&quot;)) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;wrong left path: &quot; + left);</span>
        }
<span class="nc bnc" id="L223" title="All 4 branches missed.">        if (right == null || !right.startsWith(&quot;$&quot;)) {</span>
<span class="nc" id="L224">            throw new IllegalArgumentException(&quot;wrong right path: &quot; + right);</span>
        }

<span class="nc" id="L227">        boolean ret = true;</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (!right.startsWith(left)) {</span>
<span class="nc" id="L230">            String leftPathTokens[] = left.split(Pattern.quote(&quot;.&quot;));</span>
<span class="nc" id="L231">            String rightPathTokens[] = right.split(Pattern.quote(&quot;.&quot;));</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (leftPathTokens.length &gt; rightPathTokens.length) {</span>
<span class="nc" id="L234">                ret = false;</span>
            } else {
                outerloop:
<span class="nc bnc" id="L237" title="All 2 branches missed.">                for (int cont = 0; cont &lt; leftPathTokens.length; cont++) {</span>
<span class="nc" id="L238">                    String lt = leftPathTokens[cont];</span>
<span class="nc" id="L239">                    String rt = rightPathTokens[cont];</span>

<span class="nc bnc" id="L241" title="All 10 branches missed.">                    switch (lt) {</span>
                        case &quot;*&quot;:
<span class="nc" id="L243">                            break;</span>
                        case &quot;[*]&quot;:
                            try {
<span class="nc" id="L246">                                Integer.parseInt(rt);</span>
<span class="nc" id="L247">                                break;</span>
<span class="nc" id="L248">                            } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L249">                                ret = false;</span>
<span class="nc" id="L250">                                break outerloop;</span>
                            }
                        default:
<span class="nc" id="L253">                            ret = rt.equals(lt);</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">                            if (!ret) {</span>
<span class="nc" id="L256">                                break outerloop;</span>
                            } else {
                                break;
                            }
                    }
                }
            }
        }

<span class="nc" id="L265">        LOGGER.trace(&quot;isAncestorPath: {} -&gt; {} -&gt; {}&quot;, left, right, ret);</span>
<span class="nc" id="L266">        return ret;</span>
    }

    /**
     * @param root
     * @param path
     * @return then number of properties identitified by the json path expression or null if path does not exist
     * @throws IllegalArgumentException
     */
    public static Integer countPropsFromPath(Object root, String path) throws IllegalArgumentException {
<span class="fc" id="L276">        List&lt;Optional&lt;Object&gt;&gt; items = getPropsFromPath(root, path);</span>

<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (items == null) {</span>
<span class="nc" id="L279">            return null;</span>
        }

<span class="fc" id="L282">        return items.size();</span>
    }

    private static String pathFromTokens(String[] pathTokens) {
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (pathTokens == null) {</span>
<span class="nc" id="L287">            return null;</span>
        }

<span class="nc" id="L290">        String ret = &quot;&quot;;</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (int cont = 1; cont &lt; pathTokens.length; cont++) {</span>
<span class="nc" id="L293">            ret = ret.concat(pathTokens[cont]);</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (cont &lt; pathTokens.length - 1) {</span>
<span class="nc" id="L296">                ret = ret.concat(&quot;.&quot;);</span>
            }
        }

<span class="nc" id="L300">        return ret;</span>
    }

    private static String[] subpath(String[] pathTokens) {
<span class="fc" id="L304">        ArrayList&lt;String&gt; subpath = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L306" title="All 2 branches covered.">        for (int cont = 1; cont &lt; pathTokens.length; cont++) {</span>
<span class="fc" id="L307">            subpath.add(pathTokens[cont]);</span>
        }

<span class="fc" id="L310">        return subpath.toArray(new String[subpath.size()]);</span>
    }

    public static boolean checkType(Optional&lt;Object&gt; o, String type) {
<span class="pc bpc" id="L314" title="5 of 6 branches missed.">        if (!o.isPresent() &amp;&amp; !&quot;null&quot;.equals(type) &amp;&amp; !&quot;notnull&quot;.equals(type)) {</span>
<span class="nc" id="L315">            return false;</span>
        }

<span class="pc bpc" id="L318" title="50 of 62 branches missed.">        switch (type.toLowerCase().trim()) {</span>
            case &quot;null&quot;:
<span class="nc bnc" id="L320" title="All 2 branches missed.">                return !o.isPresent();</span>
            case &quot;notnull&quot;:
<span class="nc" id="L322">                return o.isPresent();</span>
            case &quot;object&quot;:
<span class="fc" id="L324">                return o.get() instanceof BasicDBObject;</span>
            case &quot;array&quot;:
<span class="fc" id="L326">                return o.get() instanceof BasicDBList;</span>
            case &quot;string&quot;:
<span class="nc" id="L328">                return o.get() instanceof String;</span>
            case &quot;number&quot;:
<span class="fc" id="L330">                return o.get() instanceof Number;</span>
            case &quot;boolean&quot;:
<span class="nc" id="L332">                return o.get() instanceof Boolean;</span>
            case &quot;objectid&quot;:
<span class="fc" id="L334">                return o.get() instanceof ObjectId;</span>
            case &quot;objectidstring&quot;:
<span class="nc bnc" id="L336" title="All 4 branches missed.">                return o.get() instanceof String &amp;&amp; ObjectId.isValid((String) o.get());</span>
            case &quot;date&quot;:
<span class="nc" id="L338">                return o.get() instanceof Date;</span>
            case &quot;timestamp&quot;:
<span class="nc" id="L340">                return o.get() instanceof BSONTimestamp;</span>
            case &quot;maxkey&quot;:
<span class="nc" id="L342">                return o.get() instanceof MaxKey;</span>
            case &quot;minkey&quot;:
<span class="nc" id="L344">                return o.get() instanceof MinKey;</span>
            case &quot;symbol&quot;:
<span class="nc" id="L346">                return o.get() instanceof Symbol;</span>
            case &quot;code&quot;:
<span class="nc" id="L348">                return o.get() instanceof Code;</span>
            default:
<span class="nc" id="L350">                return false;</span>
        }
    }

    /**
     * @author Stefan Reich http://tinybrain.de/
     * @see http://tinybrain.de:8080/jsonminify/
     * @param jsonString
     * @return
     */
    public static String minify(String jsonString) {
<span class="fc" id="L361">        boolean in_string = false;</span>
<span class="fc" id="L362">        boolean in_multiline_comment = false;</span>
<span class="fc" id="L363">        boolean in_singleline_comment = false;</span>
<span class="fc" id="L364">        char string_opener = 'x'; // unused value, just something that makes compiler happy</span>

<span class="fc" id="L366">        StringBuilder out = new StringBuilder();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        for (int i = 0; i &lt; jsonString.length(); i++) {</span>
            // get next (c) and next-next character (cc)

<span class="fc" id="L370">            char c = jsonString.charAt(i);</span>
<span class="fc" id="L371">            String cc = jsonString.substring(i, Math.min(i + 2, jsonString.length()));</span>

            // big switch is by what mode we're in (in_string etc.)
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (in_string) {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if (c == string_opener) {</span>
<span class="fc" id="L376">                    in_string = false;</span>
<span class="fc" id="L377">                    out.append(c);</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">                } else if (c == '\\') { // no special treatment needed for \\u, it just works like this too</span>
<span class="nc" id="L379">                    out.append(cc);</span>
<span class="nc" id="L380">                    ++i;</span>
                } else {
<span class="fc" id="L382">                    out.append(c);</span>
                }
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            } else if (in_singleline_comment) {</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">                if (c == '\r' || c == '\n') {</span>
<span class="nc" id="L386">                    in_singleline_comment = false;</span>
                }
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            } else if (in_multiline_comment) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (cc.equals(&quot;*/&quot;)) {</span>
<span class="nc" id="L390">                    in_multiline_comment = false;</span>
<span class="nc" id="L391">                    ++i;</span>
                }
            } else // we're outside of the special modes, so look for mode openers (comment start, string start)
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            if (cc.equals(&quot;/*&quot;)) {</span>
<span class="nc" id="L395">                in_multiline_comment = true;</span>
<span class="nc" id="L396">                ++i;</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            } else if (cc.equals(&quot;//&quot;)) {</span>
<span class="nc" id="L398">                in_singleline_comment = true;</span>
<span class="nc" id="L399">                ++i;</span>
<span class="pc bpc" id="L400" title="1 of 4 branches missed.">            } else if (c == '&quot;' || c == '\'') {</span>
<span class="fc" id="L401">                in_string = true;</span>
<span class="fc" id="L402">                string_opener = c;</span>
<span class="fc" id="L403">                out.append(c);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            } else if (!Character.isWhitespace(c)) {</span>
<span class="fc" id="L405">                out.append(c);</span>
            }
        }
<span class="fc" id="L408">        return out.toString();</span>
    }

<span class="nc" id="L411">    private JsonUtils() {</span>
<span class="nc" id="L412">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>