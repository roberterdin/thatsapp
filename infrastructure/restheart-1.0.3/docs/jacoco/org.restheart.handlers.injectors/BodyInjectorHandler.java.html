<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BodyInjectorHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Restheart</a> &gt; <a href="index.source.html" class="el_package">org.restheart.handlers.injectors</a> &gt; <span class="el_source">BodyInjectorHandler.java</span></div><h1>BodyInjectorHandler.java</h1><pre class="source lang-java linenums">/*
 * RESTHeart - the data REST API server
 * Copyright (C) 2014 - 2015 SoftInstigate Srl
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.restheart.handlers.injectors;

import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.util.JSON;
import com.mongodb.util.JSONParseException;
import io.undertow.server.HttpServerExchange;
import io.undertow.server.handlers.form.FormData;
import io.undertow.server.handlers.form.FormDataParser;
import io.undertow.server.handlers.form.FormParserFactory;
import io.undertow.util.HeaderValues;
import io.undertow.util.Headers;
import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import org.apache.tika.Tika;
import org.restheart.hal.Representation;
import org.restheart.hal.UnsupportedDocumentIdException;
import org.restheart.handlers.PipedHttpHandler;
import org.restheart.handlers.RequestContext;
import org.restheart.utils.ChannelReader;
import org.restheart.utils.HttpStatus;
import org.restheart.utils.ResponseHelper;
import org.restheart.utils.URLUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author Andrea Di Cesare &lt;andrea@softinstigate.com&gt;
 */
public class BodyInjectorHandler extends PipedHttpHandler {

<span class="fc" id="L51">    static final Logger LOGGER = LoggerFactory.getLogger(BodyInjectorHandler.class);</span>

    static final String PROPERTIES = &quot;properties&quot;;
    static final String _ID = &quot;_id&quot;;
    static final String CONTENT_TYPE = &quot;contentType&quot;;
    static final String FILENAME = &quot;filename&quot;;

    private static final String ERROR_INVALID_CONTENTTYPE = &quot;Content-Type must be either: &quot;
            + Representation.HAL_JSON_MEDIA_TYPE
            + &quot; or &quot; + Representation.JSON_MEDIA_TYPE;

    private static final String ERROR_INVALID_CONTENTTYPE_FILE = &quot;Content-Type must be either: &quot;
            + Representation.APP_FORM_URLENCODED_TYPE
            + &quot; or &quot; + Representation.MULTIPART_FORM_DATA_TYPE;

    private final FormParserFactory formParserFactory;

    /**
     * Creates a new instance of BodyInjectorHandler
     *
     * @param next
     */
    public BodyInjectorHandler(PipedHttpHandler next) {
<span class="nc" id="L74">        super(next);</span>
<span class="nc" id="L75">        this.formParserFactory = FormParserFactory.builder().build();</span>
<span class="nc" id="L76">    }</span>

    /**
     *
     * @param exchange
     * @param context
     * @throws Exception
     */
    @Override
    public void handleRequest(final HttpServerExchange exchange, final RequestContext context) throws Exception {
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (context.getMethod() == RequestContext.METHOD.GET</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                || context.getMethod() == RequestContext.METHOD.OPTIONS</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">                || context.getMethod() == RequestContext.METHOD.DELETE) {</span>
<span class="nc" id="L89">            getNext().handleRequest(exchange, context);</span>
<span class="nc" id="L90">            return;</span>
        }

        // check the content type
<span class="nc" id="L94">        HeaderValues contentTypes = exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);</span>

<span class="nc bnc" id="L96" title="All 4 branches missed.">        if (isPutFileRequest(context) || isPostFilesbucketRequest(context)) {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (unsupportedContentTypeForFiles(contentTypes)) {</span>
<span class="nc" id="L98">                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE, ERROR_INVALID_CONTENTTYPE_FILE);</span>
<span class="nc" id="L99">                return;</span>
            }
<span class="nc bnc" id="L101" title="All 2 branches missed.">        } else if (unsupportedContentType(contentTypes)) {</span>
<span class="nc" id="L102">            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE, ERROR_INVALID_CONTENTTYPE);</span>
<span class="nc" id="L103">            return;</span>
        }

        DBObject properties;

<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (isNotFormData(contentTypes)) { // json or hal+json</span>
<span class="nc" id="L109">            final String contentString = ChannelReader.read(exchange.getRequestChannel());</span>

            try {
<span class="nc" id="L112">                properties = (DBObject) JSON.parse(contentString);</span>
<span class="nc" id="L113">            } catch (JSONParseException | IllegalArgumentException ex) {</span>
<span class="nc" id="L114">                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, &quot;Invalid JSON&quot;, ex);</span>
<span class="nc" id="L115">                return;</span>
<span class="nc" id="L116">            }</span>
<span class="nc" id="L117">        } else { // multipart form -&gt; file</span>
<span class="nc" id="L118">            FormDataParser parser = this.formParserFactory.createParser(exchange);</span>

<span class="nc bnc" id="L120" title="All 2 branches missed.">            if (parser == null) {</span>
<span class="nc" id="L121">                String errMsg = &quot;There is no form parser registered for the request content type&quot;;</span>
<span class="nc" id="L122">                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, errMsg);</span>
<span class="nc" id="L123">                return;</span>
            }

            FormData formData;

            try {
<span class="nc" id="L129">                formData = parser.parseBlocking();</span>
<span class="nc" id="L130">            } catch (IOException ioe) {</span>
<span class="nc" id="L131">                String errMsg = &quot;Error parsing the multipart form: data could not be read&quot;;</span>
<span class="nc" id="L132">                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, errMsg, ioe);</span>
<span class="nc" id="L133">                return;</span>
<span class="nc" id="L134">            }</span>

            try {
<span class="nc" id="L137">                properties = extractProperties(formData);</span>
<span class="nc" id="L138">            } catch (JSONParseException | IllegalArgumentException ex) {</span>
<span class="nc" id="L139">                String errMsg = &quot;Invalid data: 'properties' field is not a valid JSON&quot;;</span>
<span class="nc" id="L140">                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, errMsg, ex);</span>
<span class="nc" id="L141">                return;</span>
<span class="nc" id="L142">            }</span>

<span class="nc" id="L144">            final String fileField = extractFileField(formData);</span>

<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (fileField == null) {</span>
<span class="nc" id="L147">                String errMsg = &quot;This request does not contain any binary file&quot;;</span>
<span class="nc" id="L148">                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, errMsg);</span>
<span class="nc" id="L149">                return;</span>
            }

<span class="nc" id="L152">            final File file = formData.getFirst(fileField).getFile();</span>

<span class="nc" id="L154">            putFilename(formData.getFirst(fileField).getFileName(), file.getName(), properties);</span>

<span class="nc" id="L156">            LOGGER.debug(&quot;@@@ content = &quot; + properties.toString());</span>

<span class="nc" id="L158">            context.setFile(file);</span>

<span class="nc" id="L160">            injectContentTypeFromFile(properties, file);</span>
        }

<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L164">            context.setContent(null);</span>
        } else {
<span class="nc" id="L166">            filterJsonContent(properties, context);</span>

<span class="nc" id="L168">            Object _id = properties.get(_ID);</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (_id != null) {</span>
                try {
<span class="nc" id="L172">                    URLUtils.checkId(_id);</span>
<span class="nc" id="L173">                } catch (UnsupportedDocumentIdException udie) {</span>
<span class="nc" id="L174">                    String errMsg = &quot;the type of _id in content body is not supported: &quot; + _id.getClass().getSimpleName();</span>
<span class="nc" id="L175">                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, errMsg, udie);</span>
<span class="nc" id="L176">                    return;</span>
<span class="nc" id="L177">                }</span>
            }
        }

<span class="nc" id="L181">        getNext().handleRequest(exchange, context);</span>
<span class="nc" id="L182">    }</span>

    /**
     * put the filename into target DBObject
     * 
     * If filename is not null and properties don't have a filename then put the
     * filename.
     *
     * If filename is not null but properties contain a filename key then put
     * the properties filename value.
     *
     * If both filename is null and properties don't contain a filename then use
     * the default value.
     *
     * @param formDataFilename
     * @param defaultFilename
     * @param target
     */
    protected static void putFilename(final String formDataFilename, final String defaultFilename, final DBObject target) {
        // a filename attribute in optional properties overrides the provided part's filename 
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">        String filename = target.containsField(FILENAME) &amp;&amp; target.get(FILENAME) instanceof String</span>
<span class="fc" id="L203">                ? (String) target.get(FILENAME)</span>
                : formDataFilename;
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        if (filename == null || filename.isEmpty()) {</span>
<span class="fc" id="L206">            LOGGER.warn(&quot;No filename in neither multipart content disposition header nor in properties! Using default value&quot;);</span>
<span class="fc" id="L207">            filename = defaultFilename;</span>
        }
<span class="fc" id="L209">        target.put(FILENAME, filename);</span>
<span class="fc" id="L210">    }</span>

    private static boolean isPostFilesbucketRequest(final RequestContext context) {
<span class="nc bnc" id="L213" title="All 4 branches missed.">        return context.getType() == RequestContext.TYPE.FILES_BUCKET &amp;&amp; context.getMethod() == RequestContext.METHOD.POST;</span>
    }

    private static boolean isPutFileRequest(final RequestContext context) {
<span class="nc bnc" id="L217" title="All 4 branches missed.">        return context.getType() == RequestContext.TYPE.FILE &amp;&amp; context.getMethod() == RequestContext.METHOD.PUT;</span>
    }

    /**
     *
     * @param contentTypes
     * @return true if the content-type is NOT form data
     */
    private static boolean isNotFormData(final HeaderValues contentTypes) {
<span class="nc" id="L226">        return contentTypes.stream()</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                .noneMatch(ct -&gt; ct.startsWith(Representation.APP_FORM_URLENCODED_TYPE)</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                        || ct.startsWith(Representation.MULTIPART_FORM_DATA_TYPE));</span>
    }

    /**
     * Clean-up the JSON content, filtering out reserved keys and injecting the
     * request content in the ctx
     *
     * @param content
     * @param ctx
     */
    private static void filterJsonContent(final DBObject content, final RequestContext ctx) {
<span class="nc" id="L239">        filterOutReservedKeys(content, ctx);</span>
<span class="nc" id="L240">        ctx.setContent(content);</span>
<span class="nc" id="L241">    }</span>

    /**
     * Filter out reserved keys, removoing them from request
     *
     * @param content
     * @param context
     */
    private static void filterOutReservedKeys(final DBObject content, final RequestContext context) {
<span class="nc" id="L250">        final HashSet&lt;String&gt; keysToRemove = new HashSet&lt;&gt;();</span>
<span class="nc" id="L251">        content.keySet().stream()</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">                .filter(key -&gt; key.startsWith(&quot;_&quot;) &amp;&amp; !key.equals(_ID))</span>
<span class="nc" id="L253">                .forEach(key -&gt; {</span>
<span class="nc" id="L254">                    keysToRemove.add(key);</span>
<span class="nc" id="L255">                });</span>

<span class="nc" id="L257">        keysToRemove.stream().map(keyToRemove -&gt; {</span>
<span class="nc" id="L258">            content.removeField(keyToRemove);</span>
<span class="nc" id="L259">            return keyToRemove;</span>
<span class="nc" id="L260">        }).forEach(keyToRemove -&gt; {</span>
<span class="nc" id="L261">            context.addWarning(&quot;Reserved field &quot; + keyToRemove + &quot; was filtered out from the request&quot;);</span>
<span class="nc" id="L262">        });</span>
<span class="nc" id="L263">    }</span>

    private static void injectContentTypeFromFile(final DBObject content, final File file) throws IOException {
<span class="nc bnc" id="L266" title="All 4 branches missed.">        if (content.get(CONTENT_TYPE) == null &amp;&amp; file != null) {</span>
<span class="nc" id="L267">            final String contentType = detectMediaType(file);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (contentType != null) {</span>
<span class="nc" id="L269">                content.put(CONTENT_TYPE, contentType);</span>
            }
        }
<span class="nc" id="L272">    }</span>

    /**
     * true is the content-type is unsupported
     *
     * @param contentTypes
     * @return
     */
    private static boolean unsupportedContentType(final HeaderValues contentTypes) {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        return contentTypes == null</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                || contentTypes.isEmpty()</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                || contentTypes.stream().noneMatch(</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                        ct -&gt; ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE)</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                        || ct.startsWith(Representation.JSON_MEDIA_TYPE));</span>
    }

    /**
     * true is the content-type is unsupported
     *
     * @param contentTypes
     * @return
     */
    private static boolean unsupportedContentTypeForFiles(final HeaderValues contentTypes) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        return contentTypes == null</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                || contentTypes.isEmpty()</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                || contentTypes.stream().noneMatch(</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                        ct -&gt; ct.startsWith(Representation.APP_FORM_URLENCODED_TYPE)</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                        || ct.startsWith(Representation.MULTIPART_FORM_DATA_TYPE));</span>
    }

    /**
     * Search the request for a field named 'properties' which must contain
     * valid JSON
     *
     * @param formData
     * @return the parsed DBObject from the form data or an empty DBObject
     */
    protected static DBObject extractProperties(final FormData formData) throws JSONParseException {
<span class="fc" id="L310">        DBObject properties = new BasicDBObject();</span>

<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        final String propsString = formData.getFirst(PROPERTIES) != null</span>
<span class="pc" id="L313">                ? formData.getFirst(PROPERTIES).getValue()</span>
                : null;

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (propsString != null) {</span>
<span class="fc" id="L317">            properties = (DBObject) JSON.parse(propsString);</span>
        }

<span class="fc" id="L320">        return properties;</span>
    }

    /**
     * Find the name of the first file field in this request
     *
     * @param formData
     * @return the first file field name or null
     */
    private static String extractFileField(final FormData formData) {
<span class="nc" id="L330">        String fileField = null;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        for (String f : formData) {</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">            if (formData.getFirst(f) != null &amp;&amp; formData.getFirst(f).isFile()) {</span>
<span class="nc" id="L333">                fileField = f;</span>
<span class="nc" id="L334">                break;</span>
            }
<span class="nc" id="L336">        }</span>
<span class="nc" id="L337">        return fileField;</span>
    }

    /**
     * Detect the file's mediatype
     *
     * @param file input file
     * @return the content-type as a String
     * @throws IOException
     */
    public static String detectMediaType(File file) throws IOException {
<span class="nc" id="L348">        return new Tika().detect(file);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>